<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
	<ol>
		<h1><li>java代码的执行流程</li></h1>
		<h2>编译：通过javac命令(编译器)将java的源文件也就是.java文件编译成.class文件。
		<br>
		执行：先启动java虚拟机，不同的操作系统有不同的JVM，因此java跨平台。
		再通过JVM加载HelloWorld.class字节码文件。并加载main方法执行程序。</h2>
		<h1><li>标识符的命名规则</li></h1>
		<h2>标识符可以由字母、数字、下划线（_）、美元符（$）组成，但不能包含 @、%、空格等其它特殊字符。
		<br>不能以数字开头。
		<br>标识符是严格区分大小写的。
		<br>标识符不可以使用java关键字
		<br>标识符的命名最好能反映出其作用，做到见名知意。</h2>
		<h1><li>驼峰命名法</li></h1>
		<h2>命名规则，变量首字母小写，多个单词第二个之后首字母大写，java中称为驼峰规则。</h2>
		<h1><li>基本数据类型(八种)</li></h1>
		<img src="img/1.png" alt="">
		<h2>在java中，除了以上8中基本数据类型，其他的都称为引用数据类型</h2>
		<h1><li>隐式转换/显示转换</li></h1>
		<h2>小转大：自动转换/隐式转换
		<br>不需要我们操作，编译器会自动进行转换操作</h2>
		<br><h2>大转小：强制转换/显式转换
		<br>需要我们在要进行强转的变量或字面值前添加小括号（）小括号里放要转成的数据类型</h2>
		<h1><li>进制转换</li></h1>
		<h2>十进制转二进制方法：除二取余法</h2>
		<h1><li>补码的互补对称现象</li></h1>
		<h2>在补码中， 一个数的相反数等于这个数取反加一，最小值除外
		<br>归纳公式： -n = ~n+1</h2>
		<h1><li>`>>>`（逻辑右移位） 和 `>>`（数学右移位） 的区别</li></h1>
		<h2>`>>>` 逻辑右移位：只是将数字向右移动，不管正数/负数
		<br>无论正负数，将数位整体右移动，低位溢出，高位补0
		<br>`>>` 数学右移位：正数移动以后是正数，负数移动以后是负数，数学除以2以后的结果
		<br>正数，将数位整体右移动，低位溢出，高位补0 
		<br>负数，将数位整体右移动，低位溢出，高位补1，保持符号不变，结果是数学除2，向小方向取整数</h2>
		<h1><li>分支结构</li></h1>
		<h2>分支结构1：if </h2> 
		<h3>单分支：
		<br>if(boolean表达式){
		<br> 代码。。。
		<br>} <br>
		<br>双分支
		<br>if(boolean表达式){
		<br>    代码1。。。
		<br>}else{
		<br>    代码2。。。
		<br>} <br>
		<br>多分支：
		<br>if(boolean表达式1){
		<br>    代码1。。。
		<br>}else if(boolean表达式2){
		<br>    代码2。。。
		<br>} else if(boolean表达式3){
		<br>    代码3。。。
		<br>}else{
		<br>    代码4。。。
		<br>} </h3><br>
		<br><h2>分支结构2：switch </h2>
		<h3>switch(变量或者表达式){
		<br>    case 1:
		<br>    case 2:
		<br>    case 3: 
		<br>	case 4:
		<br>    default:
		<br>}</h3>
		<h1><li>跳过循环或者退出</li></h1>
		<h2>break是跳出循环
		<br>continue是跳过此次循环，执行下一次循环
		<br>return直接返回调用的main函数，后面的代码都不执行，所以不执行打印“执行完成”的语句
		<br>标记名:...break 标记名;break后指定标记名称，结束指定范围内的循环
		<h1><li>三种循环的区别</li></h1>
		<h2>1. for：知道循环次数		
		<br>2、while/do while：当循环次数不确定时		
		<br>   while：先判断，不符合规则，不执行代码	
		<br>   do while：代码最少被执行一次，再去判断，符合规则，再次执行代码</h2>
		<h1><li>创建数组的方法</li></h1>
		<h2>动态初始化</h2>
		<h3>语法：数据类型[]  数组名 = new 数据类型[数组长度];</h3>
		<h2>静态初始化</h2>
		<h3>语法：数据类型[] 数组名 = new 数据类型[] {数据元素};<br>
		简写形式：数据类型[] 数组名 = {数据元素};</h3>
		<h1><li>数组工具类Arrays</li></h1>
		<h2>Arrays.toString(数组)		
		<br>把数组里的数据，用逗号连接成一个字符串。
		<br>格式：[10, 14, 20, 46, 51]		
		<br>Arrays.sort(数组)
		<br>对数组排序，对于基本类型的数组使用优化后的快速排序算法，效率高。
		<br>对引用类型数组，使用优化后的合并排序算法。
		<br>Arrays.copyOf(数组，新的长度)
		<br>把数组复制成一个指定长度的新数组。		
		<br>新数组长度大于原数组，相当于复制，并增加位置。--数组的扩容		
		<br>新数组长度小于原数组，相当于截取前一部分数据。--数组的缩容</h2>
		<h1><li>方法的定义</li></h1>
		<h2>形式：修饰符 返回值类型 方法名(参数列表){}</h2>
		<h1><li>方法的重载</li></h1>
		<h2>方法重载是指在一个类中定义多个同名的方法，但要求每个方法具有不同的参数列表(也就是说参数的个数和类型不同)。
		<br>程序调用方法时，可以通过传递给它们的不同个数和类型的参数来决定具体使用哪个方法。</h2>
		<h1><li>排序法</li></h1>
		<h2>冒泡排序：外层循环控制比较的轮数（n个数字比较n-1轮），内层循环控制每轮比较的次数（每轮比上一轮少比一次）
		<br>较相邻的两个元素，如果不符合排序规则，进行变量值的交换<br>
		<br>插入排序：外层循环表示当前要进行插入比较的数字，内层循环表示当前数字前面所有的数字</h2>
		
	</ol>
	</body>
</html>
